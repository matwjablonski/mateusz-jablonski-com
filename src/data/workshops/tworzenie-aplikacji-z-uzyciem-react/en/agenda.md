### Introduction
- Characteristics and core principles of the library
- Environment and developer tools setup
- JavaScript / TypeScript in the context of React
- How the Virtual DOM works

### React Fundamentals
- Introduction to JSX syntax
- Creating, configuring and rendering components
- State management and state sharing
- Event handling
- Component lifecycle
- Debugging and troubleshooting

### React Hooks
- Overview of how hooks work under the hood
- Hook best practices and common pitfalls
- Immutable state management with useState and useReducer
- Correct patterns for using useEffect in StrictMode
- Working with mutable state via useRef — best practices
- Performance optimizations with hooks such as useMemo, useCallback, etc.

### React in Practice
- Building complex views
- Styling — solution overview and theme implementation
- Working with forms
- Routing
- Best practices
- Communicating with the backend
- State management strategies

### Advanced React
- Routing, meta-frameworks, and Next.js
- Form Hooks — form state and validation
- Server Components, Server Actions, and useOptimistic
- Memoization and advanced optimizations
- Suspense and lazy loading

### Working with a Selected State Management Mechanism
- React Context: Creating context providers and consumers
- React Context: Optimization and best practices

### Redux Toolkit Store (optional)
- Architectural principles
- Immutable state modeling, reducers
- Actions and action creators
- Integration with React, re-selectors
- When to choose Redux vs Context?
- Working with Redux DevTools

### MobX Observable (optional)
- How MobX State Tree works
- Practical usage patterns
- Working with DevTools
- Overview of alternatives: Jotai vs Zustand vs Recoil

### Testing (optional)
- Configuring jest/vitest with Testing Library
- Examples of using RTL selectors
- Mocking dependencies with jest
- When and what to test — discussion